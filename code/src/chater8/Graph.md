
## 그래프의 표현<hr>
그래프를 구현하는 방법은 3가지가 있다. <br><br>


### 에지 리스트<hr>
- 에지 리스트는 에지를 중심으로 그래프를 표현합니다. 
- 에지 리스트는 배열에 출발 노드, 도착 노드를 저장하여 에지를 표현합니다. 
- 출발 노드, 도착 노드, 가중치를 저장하여 가중치가 있는 에지를 표현합니다. 

**에지 리스트로 가중치 없는 그래프 표현하기**<br>
가중치가 없는 그래프는 출발 노드와 도착 노드만 표현하므로 배열의 행은 2개면 충분합니다. 

예를 들어 1->2, 1->3 , 2->4, 2->5, 4->5로 생긴 그래프라면 배열로 표현할 경우<br> 
`[ [1,2], [1,3], [3,4], [2,4], [2,5], [4,5] ]` 로 표현할 수 있습니다. 
이처럼 방향이 있는 그래프는 순서에 맞게 노드를 배열에 저장하는 방식으로 표현합니다. 
그리고 노드를 배열에 저장하여 에지를 표현하므로 에지 리스트라고 합니다.

**에지 리스트로 가중치 있는 그래프 표현하기**<br>
가중치가 있는 그래프는 행을 3개로 늘려 3번째 행에 가중치를 저장하면 됩니다. <br>
```java
1에서 2로 향하는 가중치가 8이고,
1에서 3으로 향하는 가중치가 3이고,
2에서 4로 향하는 가중치가 4이고
...
```
이런 식의 그래프가 있다면 1에서 2로 향하는 가중치는 이제 `[1,2,8]`로 표현합니다. `[시작노드,도착노드,가중치]`
이처럼 에지 리스트는 구현하기 쉽습니다. 하지만 특정 노드와 관련되어 있는 에지를 탐색하기는 쉽지 않습니다. 에지 리스트는
벨만 포드나 크루스칼 알고리즘에 사용하며, 노드 중심 알고리즘에는 잘 사용하지 않습니다.


### 인접행렬<hr>
인접 행렬은 2차원 배열을 자료구조로 이용하여 그래프를 표현합니다. 인접 행렬은 에지 리스트와 다르게 노드 중심으로 그래프를
표현합니다. 다음은 노드가 5개인 그래프를 5x5 인접 행렬로 표현한 것입니다. 

**인접 행렬로 가중치 없는 그래프 표현하기**<br>
다음 그림을 보면 1에서 2를 향하는 에지를 인접 행렬은 1행 2열에 1을 저장하는 방식으로 표현합니다.
1을 저장하는 이유는 가중치가 없기 때문입니다. 1에서 2로 향하는 에지가 있다는 표시를 노드 중심으로 한다고 
이해하면 됩니다.
```
[
    [0, 1, 1, 0, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0],
]
```
<table>
<tr>
<th>도착노드</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th>
</tr>
<tr>
<td>1</td><td></td><td>1</td><td>1</td><td></td><td></td>
</tr>
<tr>
<td>2</td><td></td><td></td><td></td><td>1</td><td>1</td>
</tr>
<tr>
<td>3</td><td></td><td></td><td></td><td>1</td><td></td>
</tr>
<tr>
<td>4</td><td></td><td></td><td></td><td></td><td>1</td>
</tr>
<tr>
<td>5</td><td></td><td></td><td></td><td></td><td></td>
</tr>
</table>


**인접 행렬로 가중치 있는 그래프 표현하기**<br>

```
[
    [0, 1, 1, 0, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 1, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0],
]
```
<table>
<tr>
<th>도착노드</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th>
</tr>
<tr>
<td>1</td><td></td><td>8</td><td>3</td><td></td><td></td>
</tr>
<tr>
<td>2</td><td></td><td></td><td></td><td>4</td><td>15</td>
</tr>
<tr>
<td>3</td><td></td><td></td><td></td><td>13</td><td></td>
</tr>
<tr>
<td>4</td><td></td><td></td><td></td><td></td><td>2</td>
</tr>
<tr>
<td>5</td><td></td><td></td><td></td><td></td><td></td>
</tr>
</table>

**정리하기**<br>
두 노드를 연결하는 에지의 여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있는 것이 장점입니다.
하지만 **노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 
공간 효율성이 떨어집니다.** 또한 **노드 개수가 많은 경우 아예 2차원 배열 선언 자체를 할 수 없는 결함도 있습니다.**
따라서 인접 행렬은 노드 개수에 따라 사용 여부를 적절하게 판단하는 능력도 필요합니다.


### 인접 리스트<br>
인접 리스트는 ArrayList로 그래프를 표현합니다. 노드 개수만큼 ArrayList를 선언합니다. 자료형은 경우에 맞게 사용합니다.

**인접 리스트로 가중치 없는 그래프 표현하기**<br>
예를 들어 노드 1과 연결된 2,3노드가 있을 때 ArrayList[1]에 [2,3]을 연결하는 방식으로 표현합니다.

**인접 리스트로 가중치 있는 그래프 표현하기**<br>
가중치가 있는 경우 자료형을 클래스로 사용합니다. `ArrayList<Node>` 와 같이 사용합니다. 
```java
class Node {
    int arriveNode;
    int addValue;
}
```
그래프를 구현하는 다른 방법에 비해 인접 리스트를 이용한 그래프 구현은 복잡한 편입니다.하지만
노드와 연결되어 있는 에지를 탐색하는 시간은 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 메모리
초과 에러도 발생하지 않습니다. 이런 장점으로 실제 코딩 테스트에서는 인접리스트를 이용한 그래프 구현을
선호합니다. 

